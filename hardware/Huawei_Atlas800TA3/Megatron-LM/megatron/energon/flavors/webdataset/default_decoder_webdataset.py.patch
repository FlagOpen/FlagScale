diff --git a/megatron/energon/flavors/webdataset/default_decoder_webdataset.py b/megatron/energon/flavors/webdataset/default_decoder_webdataset.py
new file mode 100644
index 000000000..0df68fbce
--- /dev/null
+++ b/megatron/energon/flavors/webdataset/default_decoder_webdataset.py
@@ -0,0 +1,120 @@
+# Copyright (c) 2025, NVIDIA CORPORATION.
+# SPDX-License-Identifier: BSD-3-Clause
+
+from typing import Any, Callable, Dict, Generic, Literal, Optional, TypeVar
+
+import webdataset
+
+from megatron.energon.av import AVWebdatasetDecoder
+from megatron.energon.epathlib import EPath
+from megatron.energon.flavors.webdataset.default_generic_webdataset import (
+    DefaultGenericWebdatasetFactory,
+)
+from megatron.energon.flavors.webdataset.structs import FilteredSample
+
+T_sample = TypeVar("T_sample", covariant=True)
+
+ImageDecoder = Literal[
+    "l8",
+    "rgb8",
+    "rgba8",
+    "l",
+    "rgb",
+    "rgba",
+    "torchl8",
+    "torchrgb8",
+    "torchrgba8",
+    "torchl",
+    "torchrgb",
+    "torch",
+    "torchrgba",
+    "pill",
+    "pil",
+    "pilrgb",
+    "pilrgba",
+]
+
+
+class DefaultDecoderWebdatasetFactory(DefaultGenericWebdatasetFactory[T_sample], Generic[T_sample]):
+    """
+    Extends the default webdataset loading with decoding of contained files, such as images, videos or nested
+    containers.
+    """
+
+    #: Image decoding result type
+    image_decode: ImageDecoder
+    #: If true, ignore errors when decoding.
+    ignore_decoder_errors: bool
+    #: If "AVDecoder", returns an AVDecoder instance for flexible decoding. If "torch",
+    #: returns decoded VideoData.
+    av_decode: Literal["torch", "AVDecoder", "pyav"]
+    #: Whether to decode audio from video files.
+    video_decode_audio: bool
+
+    # The webdataset decoder function, if to be applied
+    _decoder: Optional[Callable[[FilteredSample], FilteredSample]]
+
+    def __init__(
+        self,
+        path: EPath,
+        *,
+        auto_decode: bool = True,
+        image_decode: ImageDecoder = "torchrgb",
+        ignore_decoder_errors: bool = False,
+        av_decode: Literal["torch", "AVDecoder", "pyav"] = "AVDecoder",
+        video_decode_audio: bool = False,
+        **kwargs,
+    ):
+        """
+        Factory for the webdataset sample loader including the decoder.
+
+        Args:
+            path: Path to the dataset (passed to parent)
+            auto_decode: If true, use the default webdataset sample decoder.
+            image_decode: This defines the decoding results.
+            ignore_decoder_errors: If true, ignore errors when decoding.
+            audio_clip_duration: Duration of each audio clip in seconds.
+            audio_num_clips: Number of audio clips to extract (-1 for all).
+            av_decode: If "AVDecoder", returns an AVDecoder instance for flexible decoding. If "torch",
+                returns decoded VideoData.
+            video_decode_audio: Whether to decode audio from video files.
+            video_num_frames: Number of video frames to extract.
+            video_out_frame_size: Output size for video frames (width, height).
+            **kwargs: Args passed to parent constructor
+        """
+        self.image_decode = image_decode
+        self.ignore_decoder_errors = ignore_decoder_errors
+        self.av_decode = av_decode
+        self.video_decode_audio = video_decode_audio
+        super().__init__(path, **kwargs)
+
+        if auto_decode:
+            self._decoder = webdataset.autodecode.Decoder(
+                [
+                    webdataset.autodecode.imagehandler(self.image_decode),
+                    AVWebdatasetDecoder(
+                        video_decode_audio=video_decode_audio,
+                        av_decode=av_decode,
+                    ),
+                ]
+            )
+        else:
+            self._decoder = None
+
+    def _decode_error_handler(self, exc: Exception) -> bool:
+        if self.ignore_decoder_errors:
+            return True
+        raise exc
+
+    def load_sample(self, sample: FilteredSample) -> T_sample:
+        if self._decoder is not None:
+            sample = self._decoder(sample)
+        return super().load_sample(sample)
+
+    def config(self) -> Dict[str, Any]:
+        return dict(
+            **super().config(),
+            image_decode=self.image_decode,
+            ignore_decoder_errors=self.ignore_decoder_errors,
+            av_decode=self.av_decode,
+        )

