diff --git a/tools/patch/patch.py b/tools/patch/patch.py
index 61d79cc6..baf39094 100644
--- a/tools/patch/patch.py
+++ b/tools/patch/patch.py
@@ -1,14 +1,15 @@
+# -*- coding: utf-8 -*-
 import argparse
 import copy
 import os
+import re
 import shutil
-import sys
 import tempfile
 
+import git
 import yaml
 
-from encryption_utils import encrypt_file, generate_rsa_keypair
-from file_utils import sync_to_flagscale
+from encryption_utils import encrypt_file
 from git.repo import Repo
 from git_utils import (
     check_git_user_info,
@@ -19,12 +20,44 @@ from git_utils import (
 )
 from logger_utils import get_patch_logger
 
-DELETED_FILE_NAME = "deleted_files.txt"
 FLAGSCALE_BACKEND = "FlagScale"
 logger = get_patch_logger()
 
 
-def patch(main_path, submodule_name, src, dst, mode="symlink"):
+def generate_and_save_patch(sub_repo, base_commit, file_path, status, src_dir):
+
+    patch_content = ""
+    try:
+        if status in ['A', 'UT']:
+            patch_content = sub_repo.git.diff('--no-index', '/dev/null', file_path)
+
+        elif status in ['M', 'T', 'D']:
+            patch_content = sub_repo.git.diff(base_commit, '--', file_path)
+    except git.exc.GitCommandError as e:
+        if e.status == 1:
+            raw_output = str(e.stdout)
+            start_marker = "diff --git"
+            start_index = raw_output.find(start_marker)
+            end_index = raw_output.rfind("'")
+            patch_content = raw_output[start_index:end_index]
+        else:
+            raise e
+
+    if patch_content:
+        target_patch_path = os.path.join(src_dir, file_path + ".patch")
+        os.makedirs(os.path.dirname(target_patch_path), exist_ok=True)
+
+        with open(target_patch_path, 'w', encoding='utf-8') as f:
+            content = patch_content if patch_content else ""
+            if content and not content.endswith('\n'):
+                content += '\n'
+            f.write(content)
+        logger.info(f"Generated patch for '{file_path}' (Status: {status})")
+    else:
+        logger.warning(f"No patch content generated for '{file_path}' (Status: {status})")
+
+
+def patch(main_path, submodule_name, src, dst):
     """
     Sync the submodule modifications to the corresponding backend in FlagScale.
     Args:
@@ -32,12 +65,9 @@ def patch(main_path, submodule_name, src, dst, mode="symlink"):
         submodule_name (str): The name of the submodule to be patched, e.g., "Mgeatron-LM".
         src (str): The source directory of the submodule, e.g., "flagscale/backends/Megatron-LM".
         dst (str): The destination directory of the submodule, e.g., "third_party/Megatron-LM".
-        mode (str): The mode to patch (default: symlink),
-                    it means that the file will be copied to the source and a symbolic link from src to dst will be created.
-                    If the mode is copy, the file will be copied to the source and the symbolic link will not be created.
     """
 
-    submodule_path = "third_party" + "/" + submodule_name
+    submodule_path = os.path.join("third_party", submodule_name)
     logger.info(f"Patching backend {submodule_path}...")
 
     # Get the submodule repo and the commit in FlagScale.
@@ -65,42 +95,36 @@ def patch(main_path, submodule_name, src, dst, mode="symlink"):
     untracked_file_statuses = get_file_statuses_for_untracked(untracked_files)
     file_statuses.update(untracked_file_statuses)
 
-    # Process the deleted files
-    file_status_deleted = {}
-    for file_path in file_statuses:
-        if file_statuses[file_path][0] == "D":
-            file_status_deleted[file_path] = file_statuses[file_path]
-
-    # Sync the files to FlagScale and skip the deleted files firstly
-    # Temp file is used to store the deleted files
-    temp_file = tempfile.NamedTemporaryFile(mode="w", encoding="utf-8", delete=False)
-    for file_path in file_statuses:
-        if file_statuses[file_path][0] == "D":
-            continue
-        sync_to_flagscale(file_path, file_statuses[file_path], src, dst, temp_file, mode=mode)
-
-    # Process the deleted files
-    if file_status_deleted:
-        try:
-            for file_path in file_status_deleted:
-                assert file_statuses[file_path][0] == "D"
-                sync_to_flagscale(
-                    file_path, file_status_deleted[file_path], src, dst, temp_file, mode=mode
-                )
-            deleted_log = os.path.join(src, DELETED_FILE_NAME)
-            temp_file.close()
+    try:
+        # create temporary path
+        if os.path.exists(src):
+            temp_path = tempfile.mkdtemp()
+            shutil.copytree(src, temp_path, dirs_exist_ok=True)
+            logger.info(f"Created a temporary backup of '{src}' at '{temp_path}'")
+
+        logger.info(f"Cleaning up old patch directory: {src}")
+        shutil.rmtree(src, ignore_errors=True)
+        os.makedirs(src)
+
+        if not file_statuses:
+            logger.info("No file changes detected. Nothing to patch.")
+
+        else:
+            logger.info(f"Found {len(file_statuses)} file change(s). Generating patches...")
+            for file_path, status_info in file_statuses.items():
+                status = status_info[0]
+                generate_and_save_patch(sub_repo, submodule_commit_in_fs, file_path, status, src)
+            logger.info("Patch generation completed successfully!")
 
-            shutil.move(temp_file.name, deleted_log)
-            if os.path.lexists(temp_file.name):
-                os.remove(temp_file.name)
+    except Exception as e:
+        logger.error(f"An error occurred during patch generation: {e}", exc_info=True)
+        shutil.rmtree(src, ignore_errors=True)
+        shutil.copytree(temp_path, src, dirs_exist_ok=True)
 
-        except Exception as e:
-            print(f"Error occurred while processing deleted files: {e}")
-            # Rollback
-            temp_file.close()
-            if os.path.lexists(temp_file.name):
-                os.remove(temp_file.name)
-            raise e
+    finally:
+        if "temp_path" in locals() and os.path.exists(temp_path):
+            logger.info(f"Cleaning up temp path: {temp_path}")
+            shutil.rmtree(temp_path, ignore_errors=True)
 
 
 def patch_hardware(main_path, commit, backends, device_type, tasks, key_path=None):
@@ -117,7 +141,7 @@ def prompt_info(main_path, backends, device_type, tasks):
     logger.info("Prompting for patch information: ")
 
     backends_version = {}
-    print("1. Please enter backends version: ")
+    logger.info("1. Please enter backends version: ")
     for backend in backends:
         version = input(f"    {backend} version: ").strip()
         while not version:
@@ -126,7 +150,7 @@ def prompt_info(main_path, backends, device_type, tasks):
         backends_version[backend] = version
 
     backends_commit = {}
-    print("2. Please enter backends commit: ")
+    logger.info("2. Please enter backends commit: ")
     logger.info(
         "If a specific submodule commit is provided, it will be used to generate the diff and apply the patch. By default, the commit defined by FlagScale will be used."
     )
@@ -139,7 +163,7 @@ def prompt_info(main_path, backends, device_type, tasks):
 
     # FlagScale-compatible models
     model_input = input(
-        "3. Please enter flagScale-compatible models (separated with commas): "
+        "3. Please enter FlagScale-compatible models (separated with commas): "
     ).strip()
     models = [m.strip() for m in model_input.split(",") if m.strip()]
     while not models:
@@ -191,8 +215,9 @@ def _generate_patch_file_for_backend(
     repo = Repo(main_path)
     assert not repo.bare
     try:
+        patch_dir = os.path.join(main_path, "hardware", patch_info["device_type"], backend)
         repo_path = (
-            os.path.join(main_path, "third_party" + "/" + backend)
+            os.path.join(main_path, "third_party", backend)
             if backend != FLAGSCALE_BACKEND
             else main_path
         )
@@ -239,16 +264,11 @@ def _generate_patch_file_for_backend(
         if backend == FLAGSCALE_BACKEND:
             backends = copy.deepcopy(list(patch_info["backends_version"].keys()))
             flagscale_diff_args = [commit, "HEAD", "--binary", "--ignore-submodules=all", "--"]
-            for backend in backends:
-                if backend != FLAGSCALE_BACKEND:
-                    backend_dir = os.path.join(main_path, "flagscale", "backends", backend)
+            for item in backends:
+                if item != FLAGSCALE_BACKEND:
+                    backend_dir = os.path.join(main_path, "flagscale", "backends", item)
                     flagscale_diff_args.append(f':(exclude){backend_dir}')
 
-        temp_patch_files = []
-        # Generate patch for each backend
-        temp_file = tempfile.NamedTemporaryFile(delete=False, mode="w", encoding="utf-8")
-        temp_patch_path = temp_file.name
-        temp_patch_files.append(temp_patch_path)
         diff_data = (
             repo.git.diff(commit, "HEAD", "--binary")
             if backend != FLAGSCALE_BACKEND
@@ -257,26 +277,47 @@ def _generate_patch_file_for_backend(
         if not diff_data:
             raise ValueError(f"No changes in backend {backend}.")
 
-        temp_file.write(diff_data)
-        # add \n to the end of the file
-        temp_file.write("\n")
-        temp_file.flush()
+        splits = re.split(r'(?=^diff --git a/)', diff_data, flags=re.MULTILINE)
+
+        temp_patch_files_with_relpath = []
+        for file_diff in splits:
+            if not file_diff.strip():
+                continue
+
+            m = re.match(r'diff --git a/.+ b/(.+)', file_diff.splitlines()[0])
+            if not m:
+                continue
+            filepath = m.group(1)  # relative path like megatron/train.py
+
+            temp_file = tempfile.NamedTemporaryFile(
+                delete=False, mode="w", encoding="utf-8", suffix=".patch"
+            )
+            temp_file.write(file_diff)
+
+            temp_file.write("\n")
+            temp_file.flush()
+            temp_file.close()
+
+            temp_patch_files_with_relpath.append((temp_file.name, filepath))
+
         if key_path is not None:
-            temp_patch_path = encrypt_file(temp_patch_path, key_path)
-            logger.info(f"Encrypted patch file {temp_patch_path} with public key.")
+            encrypted_files_with_relpath = []
+            for patch_path, rel_path in temp_patch_files_with_relpath:
+                encrypted_path = encrypt_file(patch_path, key_path)
+                encrypted_files_with_relpath.append((encrypted_path, rel_path))
+            temp_patch_files_with_relpath = encrypted_files_with_relpath
 
         temp_yaml_file = tempfile.NamedTemporaryFile(
             delete=False, mode="w", encoding="utf-8", suffix=".yaml"
         )
         temp_yaml_path = temp_yaml_file.name
-        temp_patch_files.append(temp_yaml_path)
         data = copy.deepcopy(patch_info)
         assert flagscale_commit is not None, "FlagScale commit must be specified."
         data["commit"] = flagscale_commit
-        del data["commit_msg"]
+        if "commit_msg" in data:
+            del data["commit_msg"]
         yaml.dump(data, temp_yaml_file, sort_keys=True, allow_unicode=True)
         temp_yaml_file.flush()
-        patch_dir = os.path.join(main_path, "hardware", patch_info["device_type"], backend)
 
         # Step5: Checkout to current branch and pop the stash.
         logger.info(f"Step 5: Checkouting to current branch and pop the stash...")
@@ -302,7 +343,7 @@ def _generate_patch_file_for_backend(
             logger.error(f"Failed to roll back: {cleanup_error}", exc_info=True)
             raise cleanup_error
 
-    return patch_dir, temp_patch_path, temp_yaml_path
+    return patch_dir, temp_patch_files_with_relpath, temp_yaml_path
 
 
 def generate_patch_file(main_path: str, commit: str, patch_info: dict, key_path=None):
@@ -321,42 +362,41 @@ def generate_patch_file(main_path: str, commit: str, patch_info: dict, key_path=
             if backend != FLAGSCALE_BACKEND:
                 # Get the submodule repo and the commit in FlagScale.
                 main_repo = Repo(main_path)
-                submodule_path = "third_party" + "/" + backend
+                submodule_path = os.path.join("third_party", backend)
                 submodule = main_repo.submodule(submodule_path)
-                sub_repo = submodule.module()
                 submodule_commit_in_fs = repo.head.commit.tree[submodule_path].hexsha
                 if backend in patch_info["backends_commit"]:
                     submodule_commit_in_fs = patch_info["backends_commit"][backend]
-                patch_dir, temp_patch_path, temp_yaml_path = _generate_patch_file_for_backend(
-                    main_path,
-                    submodule_commit_in_fs,
-                    backend,
-                    patch_info,
-                    key_path=key_path,
-                    flagscale_commit=commit,
+                patch_dir, patch_files_with_relpath, temp_yaml_path = (
+                    _generate_patch_file_for_backend(
+                        main_path,
+                        submodule_commit_in_fs,
+                        backend,
+                        patch_info,
+                        key_path=key_path,
+                        flagscale_commit=commit,
+                    )
                 )
             else:
-                patch_dir, temp_patch_path, temp_yaml_path = _generate_patch_file_for_backend(
-                    main_path,
-                    commit,
-                    backend,
-                    patch_info,
-                    key_path=key_path,
-                    flagscale_commit=commit,
+                patch_dir, patch_files_with_relpath, temp_yaml_path = (
+                    _generate_patch_file_for_backend(
+                        main_path,
+                        commit,
+                        backend,
+                        patch_info,
+                        key_path=key_path,
+                        flagscale_commit=commit,
+                    )
                 )
-            patches[backend] = [patch_dir, temp_patch_path, temp_yaml_path]
+            patches[backend] = [patch_dir, patch_files_with_relpath, temp_yaml_path]
 
         logger.info(f"Checking out {commit}...")
         repo.git.checkout(commit)
 
-        # Stage the patch file.
-        logger.info("Staging the generated patch file...")
-        file_name = f"diff.patch" if key_path is None else f"diff.patch.encrypted"
-        yaml_file_name = f"diff.yaml"
+        logger.info("Staging the generated patch files...")
         patch_dir_need_to_clean = []
-        temp_patch_files = []
         for backend in patches:
-            patch_dir, temp_patch_path, temp_yaml_path = patches[backend]
+            patch_dir, patch_files_with_relpath, temp_yaml_path = patches[backend]
             patch_dir_exist = os.path.exists(patch_dir)
 
             if not patch_dir_exist:
@@ -365,18 +405,32 @@ def generate_patch_file(main_path: str, commit: str, patch_info: dict, key_path=
             # Remove the backend
             if os.path.exists(patch_dir):
                 shutil.rmtree(patch_dir)
+                repo.git.rm('-r', patch_dir, ignore_unmatch=True)
             os.makedirs(patch_dir, exist_ok=True)
-            shutil.copy(temp_patch_path, os.path.join(patch_dir, file_name))
-            shutil.copy(temp_yaml_path, os.path.join(patch_dir, yaml_file_name))
-            repo.git.add(os.path.join(patch_dir, file_name))
-            repo.git.add(os.path.join(patch_dir, yaml_file_name))
-            temp_patch_files.append(temp_patch_path)
+
+            # Copy each patch file preserving relative path inside patch_dir
+            for temp_patch_path, rel_path in patch_files_with_relpath:
+                dst_patch_path = (
+                    os.path.join(patch_dir, f"{rel_path}.patch")
+                    if key_path is None
+                    else os.path.join(patch_dir, f"{rel_path}.patch.encrypted")
+                )
+                os.makedirs(os.path.dirname(dst_patch_path), exist_ok=True)
+                shutil.copy(temp_patch_path, dst_patch_path)
+                repo.git.add(dst_patch_path)
+                temp_patch_files.append(temp_patch_path)
+
+            # Copy yaml file
+            yaml_file_name = "diff.yaml"
+            dst_yaml_path = os.path.join(patch_dir, yaml_file_name)
+            shutil.copy(temp_yaml_path, dst_yaml_path)
+            repo.git.add(dst_yaml_path)
             temp_patch_files.append(temp_yaml_path)
 
         # Commit the patch file with the same message.
         logger.info("Committing the patch file...")
         commit_msg = patch_info["commit_msg"]
-        repo.git.commit("-m", commit_msg)
+        repo.git.commit("--no-verify", "-m", commit_msg)
 
         logger.info(
             "Commit successfully! If you want to push, try 'git push origin HEAD:refs/heads/(your branch)' or  'git push --force origin HEAD:refs/heads/(your branch)'"
@@ -419,9 +473,10 @@ def validate_patch_args(device_type, task, commit, main_path):
         if (
             device_type.count("_") != 1
             or len(device_type.split("_")) != 2
+            or not device_type.split("_")[0]
             or not device_type.split("_")[0][0].isupper()
         ):
-            raise ValueError("Device type is not invalid!")
+            raise ValueError("Device type is invalid!")
 
     if commit or device_type or task:
         assert (
@@ -454,6 +509,10 @@ def normalize_backend(backend):
         return "sglang"
     elif input_lower in ["llama.cpp", "llama_cpp"]:
         return "llama.cpp"
+    elif input_lower in ["omniinfer", "omni_infer", "OmniInfer"]:
+        return "omniinfer"
+    elif input_lower in ["verl"]:
+        return "verl"
 
     raise ValueError(f'Unsupported backend {backend}')
 
@@ -469,13 +528,6 @@ if __name__ == "__main__":
         default=["Megatron-LM"],
         help="Backend to patch (default: Megatron-LM)",
     )
-
-    parser.add_argument(
-        "--mode",
-        choices=["symlink", "copy"],
-        default="symlink",
-        help="Mode to patch (default: symlink, it means that the file will be copied to the source and a symbolic link will be created)",
-    )
     parser.add_argument(
         "--commit", type=str, default=None, help="Patch based on this commit. Default is None."
     )
@@ -492,7 +544,6 @@ if __name__ == "__main__":
 
     args = parser.parse_args()
     backends = args.backend
-    mode = args.mode
     commit = args.commit
     tasks = args.task
     device_type = args.device_type
@@ -525,4 +576,4 @@ if __name__ == "__main__":
         for backend in backends:
             dst = os.path.join(main_path, "third_party", backend)
             src = os.path.join(main_path, "flagscale", "backends", backend)
-            patch(main_path, backend, src, dst, mode)
+            patch(main_path, backend, src, dst)

